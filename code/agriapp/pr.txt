 I want before sumbitQuestion uploaded files to supabase from camara or select file and when sumbitQuestion added to QuestionMedia,

 also show every files process and when click remove delete from file supabase or cancle upload process if running , 
 bucket 'chat' and every user must has id folder same id user and in folder user must has folders for every questions same id Question  
 
  import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:social_media_recorder/audio_encoder_type.dart';
import 'package:social_media_recorder/screen/social_media_recorder.dart';
import 'package:camerawesome/camerawesome_plugin.dart';
import '../../controllers/chat_ai_chat_controller.dart';
import 'image_preview.dart';

class CustomInputField extends GetView<ChatAiChatController> {
  final String hintText;

  const CustomInputField({
    Key? key,
    required this.hintText,
    required Function(String value) onSubmitted,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Obx(() {
          if (controller.isRecording.value) {
            return SocialMediaRecorder(
              startRecording: () {},
              stopRecording: (_time) {},
              sendRequestFunction: (soundFile, _time) {
                controller.selectedMediaFiles.add(soundFile);
              },
              encode: AudioEncoderType.AAC,
            );
          } else {
            return Column(
              children: [
                if (controller.selectedMediaFiles.isNotEmpty)
                  Obx(() {
                    return Wrap(
                      spacing: 8.0,
                      runSpacing: 8.0,
                      children: List.generate(
                        controller.selectedMediaFiles.length,
                        (index) => ImagePreview(
                          imagePath: controller.selectedMediaFiles[index].path,
                          onRemove: () => controller.removeSelectedMedia(index),
                          progress: controller.mediaUploadProgress[index],
                        ),
                      ),
                    );
                  }),
                Container(
                  decoration: BoxDecoration(
                    color: Colors.white,
                    border: Border.all(color: Colors.grey, width: 1), // Add border
                    borderRadius: BorderRadius.circular(8), // Rounded corners
                  ),
                  padding: const EdgeInsets.symmetric(horizontal: 5.0, vertical: 5.0),
                  child: Row(
                    children: [
                      Expanded(
                      child: TextField(
                          controller: controller.textController,
                          decoration: InputDecoration(
                            hintText: hintText,
                            hintStyle: TextStyle(color: Colors.grey[400]),
                            border: InputBorder.none, // No border
                            focusedBorder: InputBorder.none, // No border when focused
                            enabledBorder: InputBorder.none, // No border when enabled
                            fillColor: Colors.transparent, // No fill color
                            filled: false, // Ensure no fill color is applied
                          ),
                          maxLines: 4,
                          minLines: 1,
                          keyboardType: TextInputType.multiline,
                        ),
                      ),
                      SizedBox(width: 8), // Gap between icons
                      Obx(() => Visibility(
                        visible: controller.isTextEmpty.value && !controller.isLoadingAnswerAI.value && controller.isAudioAllow(),
                        child: _buildIconButton(
                          icon: Icons.mic,
                          color: Colors.blue, // Ensure color is non-nullable
                          onPressed: () {},
                        ),
                      )),
                      SizedBox(width: 8), // Gap between icons
                      Obx(() => Visibility(
                        visible: controller.isImageAllow(),
                        child: _buildIconButton(
                          icon: Icons.camera_alt,
                          color: Colors.blue, // Ensure color is non-nullable
                          onPressed: () async {
                            final capturedImage = await Navigator.push(
                              context,
                              MaterialPageRoute(
                                builder: (context) => CameraAwesomePage(),
                              ),
                            );
                            if (capturedImage != null) {
                              controller.selectedMediaFiles.add(capturedImage);
                            }
                          },
                        ),
                      )),
                      SizedBox(width: 8), // Gap between icons
                      Obx(() => Visibility(
                        visible: controller.isImageAllow(),
                        child: _buildIconButton(
                          icon: Icons.attach_file,
                          color: Colors.blue, // Ensure color is non-nullable
                          onPressed: controller.pickMultipleMedia,
                        ),
                      )),
                      SizedBox(width: 8), // Gap between icons
                      Obx(() => controller.isLoadingAnswerAI.value
                        ? _buildIconButton(
                            icon: Icons.stop,
                            color: Colors.red, // Ensure color is non-nullable
                            onPressed: () {
                              controller.stopAIResponse();
                            },
                          )
                        : _buildIconButton(
                            icon: Icons.send,
                            color: controller.isTextEmpty.value ? Colors.grey[400]! : Colors.blue, // Ensure color is non-nullable
                            onPressed: controller.isTextEmpty.value
                                ? null
                                : () {
                                    controller.submitQuestion(controller.textController.text);
                                  },
                          ),
                      ),
                    ],
                  ),
                ),
              ],
            );
          }
        }),
      ],
    );
  }


  Widget _buildIconButton({
    required IconData icon,
    required Color color,
    required VoidCallback? onPressed,
  }) {
    return SizedBox(
      width: 30,
      height: 30,
      child: CircleAvatar(
        backgroundColor: color, // Background color of the icon button
        child: IconButton(
          icon: Icon(icon, color: Colors.white),
          onPressed: onPressed,
          splashRadius: 20, // Adjust splash radius if needed
          padding: EdgeInsets.zero,
          iconSize: 18, // Adjust icon size if needed
        ),
      ),
    );
  }
}

class CameraAwesomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: CameraAwesomeBuilder.awesome(
        saveConfig: SaveConfig.photo(),
        onMediaTap: (mediaCapture) {
          print(mediaCapture);
          Navigator.pop(context, mediaCapture);
        },
      ),
    );
  }
}


import 'package:agri_ai/app/controllers/auth_controller.dart';
import 'package:get/get.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

import '../models/conversation_model.dart';

class ConversationProvider extends GetConnect {
  final supabase = Supabase.instance.client;

  late final String userId;

  @override
  void onInit() async {
    super.onInit();
    AuthController authController = Get.find<AuthController>();
    userId = authController.getCurrentUserId();
    //  userId = "3b431bd9-edf9-4bc5-9e81-73d6dde8adda";
  }

  Future<List<Conversation>> getConversations({
    int page = 1,
    String type = 'AI',
  }) async {
    final response = await supabase
        .from('conversation')
        .select()
        .eq('user_id', userId)
        .eq('type', type) 
        .order('created_at', ascending: false)
        .range((page - 1) * 10, page * 10 - 1);

    print(response);

    return (response as List)
        .map((item) => Conversation.fromJson(item))
        .toList();
  }

  Future<Conversation?> getConversationById(String conversationId) async {
    final response = await supabase
        .from('conversation')
        .select()
        .eq('id', conversationId)
        .single();

    return response != null ? Conversation.fromJson(response) : null;
  }

  Future<Conversation> addNewConversation(String title) async {
    final response = await supabase
        .from('conversation')
        .insert({
          'user_id': userId,
          'title': title,
        })
        .select()
        .single();

    return Conversation.fromJson(response);
  }

  Future<List<Question>> getListQuestionAnswerByConversationId(
      String conversationId) async {
    final response = await supabase
        .from('question')
        .select('*, answer(*), question_media(*)')
        .eq('conversation_id', conversationId);

    print(response);
    final data = response as List<dynamic>;
    return data.map((item) => Question.fromJson(item)).toList();
  }




  Future<String> createConversation(String title, String type) async {
    final response = await supabase
        .from('conversation')
        .insert({
          'user_id': userId,
          'title': title,
          'type': type,
        })
        .select()
        .single();

    return response['id'] as String;
  }

  Future<String> insertQuestion(String conversationId, String content, List<QuestionMedia> media) async {
    final response = await supabase
        .from('question')
        .insert({
          'conversation_id': conversationId,
          'content': content,
        })
        .select()
        .single();

    String questionId = response['id'] as String;

    // Insert media if any
    if (media.isNotEmpty) {
      await supabase.from('question_media').insert(
        media.map((m) => {
          'question_id': questionId,
          'media_url': m.mediaUrl,
          'media_type': m.mediaType,
        }).toList(),
      );
    }

    return questionId;
  }

  Future<String> insertAnswer(String questionId, String content, {String? status}) async {
    final response = await supabase
        .from('answer')
        .insert({
          'question_id': questionId,
          'content': content,
          'status': status,
        })
        .select()
        .single();

    return response['id'] as String;
  }

  Future<void> updateAnswer(String answerId, String content, {String? status}) async {
    await supabase
        .from('answer')
        .update({
          'content': content,
          'status': status,
          'updated_at': DateTime.now().toIso8601String(),
        })
        .eq('id', answerId);
  }



 Future<void> insertQuestionAndAnswer({
    required String conversationId,
    required String questionId,
    required String questionContent,
    required String answerId,
    required String answerContent,
    List<QuestionMedia> media = const [],
    String? answerStatus,
  }) async {
    try {
      // Insert question with the given questionId
      await supabase.from('question').insert({
        'id': questionId,
        'conversation_id': conversationId,
        'content': questionContent,
      });

      // Insert media if any
      if (media.isNotEmpty) {
        await supabase.from('question_media').insert(
          media.map((m) => {
        
            'question_id': questionId,
            'media_url': m.mediaUrl,
            'media_type': m.mediaType,
          }).toList(),
        );
      }

      // Insert answer with the given answerId
      await supabase.from('answer').insert({
        'id': answerId,
        'question_id': questionId,
        'content': answerContent,
        'status': answerStatus,
      });
    } catch (e) {
      throw Exception('Failed to insert question and answer: $e');
    }
  }

}



  import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'package:agri_ai/app/data/models/conversation_model.dart';
import 'package:agri_ai/app/data/providers/app_setting_provider.dart';
import 'package:agri_ai/app/data/providers/conversation_provider.dart';
import 'package:agri_ai/app/modules/chat/ai_chat/views/widgets/chat_drawer/chat_drawer.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:image_picker/image_picker.dart';
import 'package:uuid/uuid.dart';
import 'package:flutter/services.dart';
import 'package:http/http.dart' as http;
import 'package:file_picker/file_picker.dart';

class ChatAiChatController extends GetxController {
  final ConversationProvider provider = Get.put(ConversationProvider());
  final TextEditingController textController = TextEditingController();
  final ScrollController scrollController = ScrollController();
  final uuid = const Uuid();

   final AppSettingProvider appSettingProvider = Get.find();

  final isTextEmpty = true.obs;
  final isLoadingAnswerAI = false.obs;
  final selectedMediaPath = ''.obs;
  final selectedMediaFiles = <File>[].obs;
  final mediaUploadProgress = <double>[].obs;
  final isRecording = false.obs;
  final isPaused = false.obs;
  final isLoadingQuestions = false.obs;
  final isLoading = true.obs;
  final isLoadingConversations = true.obs;
  final isLoadingMore = false.obs;
  final hasMoreConversations = true.obs;

  final listConversations = <Conversation>[].obs;
  final currentConversation = Rxn<Conversation>();
  final drawerList = <DrawerList>[].obs;

  int currentPage = 1;
  StreamSubscription<String>? _aiResponseSubscription;
  Conversation get defaultConversation => Conversation(
        id: '',
        userId: 'default_user',
        title: 'New Conversation',
        createdAt: DateTime.now().toIso8601String(),
        updatedAt: DateTime.now().toIso8601String(),
        question: [],
      );

  @override
  void onInit() {
    super.onInit();
  initializeSetup();
  }
 void initializeSetup() {
    textController.addListener(_updateTextEmpty);
    SystemChannels.textInput.invokeMethod('TextInput.hide');
    setDefaultConversation();
    ever(listConversations, (_) => scrollToBottom());
  }
  @override
  Future<void> onReady() async {
    super.onReady();
    await loadConversations();
  }

  void _updateTextEmpty() => isTextEmpty.value = textController.text.isEmpty;

  void setCurrentConversation(Conversation conversation) {
    currentConversation.value = conversation;
  }

  bool isDefaultConversation() => currentConversation.value?.id == '';
  bool isCurrentAgriConv() => currentConversation.value?.type == 'Agri-Expert';
  void setDefaultConversation() {
    if (!listConversations.any((c) => c.id == defaultConversation.id)) {
      listConversations.add(defaultConversation);
    }
    setCurrentConversation(defaultConversation);
  }

  Conversation get getCurrentConversation =>
      currentConversation.value ?? defaultConversation;

  void updateConversation(void Function(Conversation) updater) {
    currentConversation.update((val) {
      if (val != null) {
        updater(val);
        int index = listConversations.indexWhere((c) => c.id == val.id);
        if (index != -1) {
          listConversations[index] = val;
          
          listConversations.refresh();
        }
      }
    });
  }

  String getMediaType(String extension) {
    switch (extension) {
      case 'jpg':
      case 'jpeg':
      case 'png':
      case 'gif':
        return 'image';
      case 'mp3':
      case 'wav':
      case 'm4a':
        return 'audio';
      default:
        return 'unknown';
    }
  }



  void submitQuestion(String content) async {
    isLoadingAnswerAI.value = true;
    SystemChannels.textInput.invokeMethod('TextInput.hide');
    scrollToBottom();

    var questionId = uuid.v1();
    var answerId = uuid.v1();
    textController.clear();

    Question newQuestion = Question(
      id: questionId,
      conversationId: getCurrentConversation.id!,
      content: content,
      createdAt: DateTime.now().toIso8601String(),
      updatedAt: DateTime.now().toIso8601String(),
      questionMedia: selectedMediaFiles.map((file) {
        String extension = file.path.split('.').last.toLowerCase();
        String mediaType = getMediaType(extension);
        return QuestionMedia(
          id: const Uuid().v4(),
          questionId: questionId,
          mediaType: mediaType,
       
          mediaUrl: file.path, 
        );
      }).toList(),
    );

    Answer aiAnswer = Answer(
      id: answerId,
      questionId: newQuestion.id,
      content: '',
      isLoading: true,
      createdAt: DateTime.now().toIso8601String(),
      updatedAt: DateTime.now().toIso8601String(),
    );
if (isCurrentAgriConv()){
   aiAnswer.status = 'pending';
   aiAnswer.isLoading = false;
}
    updateConversation((val) {
      val.question ??= [];
      val.question!.add(newQuestion);
      newQuestion.answer ??= [];
      newQuestion.answer!.add(aiAnswer);
    });

    selectedMediaFiles.clear();
    mediaUploadProgress.clear();
    simulateAIResponse();
     
  }




  void simulateAIResponse() {
    Stream<String> aiResponseStream = simulateStreamingAPIResponse();

    _aiResponseSubscription = aiResponseStream.listen(
      (chunk) {
        updateConversation((val) {
          if (val.question != null && val.question!.isNotEmpty) {
            Question lastQuestion = val.question!.last;
            if (lastQuestion.answer != null &&
                lastQuestion.answer!.isNotEmpty) {
              Answer lastAnswer = lastQuestion.answer!.last;
              lastAnswer.content = (lastAnswer.content ?? '') + chunk;
            }
          }
        });
        scrollToBottom();
      },
      onError: (error) => handleAIResponseError(error),
      onDone: () => finalizeAIResponse(),
      cancelOnError: true,
    );

   
  }




 void handleAIResponseError(dynamic error) {
    isLoadingAnswerAI.value = false;
    updateConversation((val) {
      if (val.question != null && val.question!.isNotEmpty) {
        Question lastQuestion = val.question!.last;
        if (lastQuestion.answer != null && lastQuestion.answer!.isNotEmpty) {
          Answer lastAnswer = lastQuestion.answer!.last;
          lastAnswer.isError = true;
        }
      }
    });
  }


 



  void finalizeAIResponse() async{
    updateConversation((val) {
      if (val.question != null && val.question!.isNotEmpty) {
        Question lastQuestion = val.question!.last;
        if (lastQuestion.answer != null && lastQuestion.answer!.isNotEmpty) {
          lastQuestion.answer!.last.isLoading = false;
        }
      }
    });
    isLoadingAnswerAI.value = false;
    scrollToBottom();

       // Get the latest question and answer
    Question? latestQuestion;
  Answer? latestAnswer;
  
  if (getCurrentConversation.question != null && getCurrentConversation.question!.isNotEmpty) {
    latestQuestion = getCurrentConversation.question!.last;
    if (latestQuestion.answer != null && latestQuestion.answer!.isNotEmpty) {
      latestAnswer = latestQuestion.answer!.last;
    }
  }

  // Insert conversation data into Supabase
  if (latestQuestion != null && latestAnswer != null) {
    await insertConversationDataIntoSupabase(latestQuestion, latestAnswer);
  }
  }



Future<void> insertConversationDataIntoSupabase(Question question, Answer answer) async {
  try {
  
    if ((question.content?.isNotEmpty ?? false) && (answer.content?.isNotEmpty ?? false)) {
      String conversationId;

  
      if (isDefaultConversation()) {
         
      String conversationTitle = (question.content!.length > 100)
          ? question.content!.substring(0, 100)
          : question.content!;
        conversationId = await provider.createConversation(conversationTitle, 'AI');
      
        updateConversation((val) {
          val.id = conversationId;
          val.title = conversationTitle;
        });

         
   
      updateDrawerList();
      } else {
        
        conversationId = getCurrentConversation.id!;
      }


  // Use the existing IDs for question and answer
      await provider.insertQuestionAndAnswer(
        conversationId: conversationId,
        questionId: question.id!, // Use existing question ID
        questionContent: question.content!,
        answerId: answer.id!, // Use existing answer ID
        answerContent: answer.content!,
        media: question.questionMedia ?? [],
        answerStatus: answer.status,
      );
      // Insert question
      // String questionId = await provider.insertQuestion(
      //   conversationId,
      //   question.content!, 
      //   question.questionMedia ?? [],
      // );

      // // Insert answer
      // await provider.insertAnswer(
      //   questionId,
      //   answer.content!, 
      //   status: answer.status,
      // );

      print('Conversation data successfully inserted into Supabase');
    
    } else {
      // Handle cases where question content or answer content is null or empty
      print('Question content or answer content is null or empty');
    }
  } catch (e) {
    print('Error inserting conversation data into Supabase: $e');
    // Handle the error appropriately, maybe show a snackbar to the user
  }
}

 void scrollToBottom() {
  if (scrollController.hasClients) {
    scrollController.animateTo(
      scrollController.position.maxScrollExtent,
      duration: Duration(milliseconds: 300),
      curve: Curves.easeOut,
    );
  }
}



Stream<String> simulateStreamingAPIResponse() async* {
   

  // Check if appSetting is valid
  if (appSettingProvider.appSetting.value == null) {
    throw Exception('App settings not found');
  }

  final defaultAiModel = appSettingProvider.appSetting.value?.defaultAiModel;
  if (defaultAiModel == null) {
    throw Exception('Default AI model settings not found');
  }

  final company = defaultAiModel.company;
  if (company == null) {
    throw Exception('Company settings not found in AI model');
  }

  if (company.apiUrl == null || company.apiKey == null) {
    throw Exception('API URL or API key is missing in company settings');
  }

  final apiUrl = company.apiUrl!;
  final apiKey = company.apiKey!;

  final headers = {
    'Authorization': 'Bearer $apiKey',
    'Content-Type': 'application/json'
  };

  // Build the message history
  List<Map<String, String>> messages = [{"role": "system", "content": appSettingProvider.appSetting.value?.defaultMessage ?? ''}];
  for (var q in getCurrentConversation.question ?? []) {
    messages.add({"role": "user", "content": q.content ?? ''});
    for (var a in q.answer ?? []) {
      messages.add({"role": "assistant", "content": a.content ?? ''});
    }
  }

  final body = json.encode({
    "model": defaultAiModel.modelCode ?? '',
    "messages": messages,
    "max_tokens": defaultAiModel.maxTokens ?? 512,
    "temperature": defaultAiModel.temperature ?? 0.7,
    "top_p": defaultAiModel.topP ?? 0.7,
    "top_k": defaultAiModel.topK ?? 50,
    "repetition_penalty": defaultAiModel.repetitionPenalty ?? 1,
    "stop": defaultAiModel.stop ?? ["[/INST]", "</s>"],
    "stream": defaultAiModel.stream ?? true
  });

  final request = http.Request('POST', Uri.parse(apiUrl))
    ..headers.addAll(headers)
    ..body = body;

  final response = await request.send();

  if (response.statusCode == 200) {
    String accumulatedData = '';
    await for (var chunk in response.stream.transform(utf8.decoder)) {
      accumulatedData += chunk;
      // Split the accumulated data into lines
      final lines = accumulatedData.split('\n');
      for (var line in lines) {
        if (line.startsWith('data: ')) {
          final jsonString = line.substring(6);
          if (jsonString == '[DONE]') {
            return;
          }
          try {
            final decodedData = json.decode(jsonString);
            if (decodedData is Map && decodedData.containsKey('choices')) {
              final choices = decodedData['choices'];
              for (var choice in choices) {
                if (choice.containsKey('delta') &&
                    choice['delta'].containsKey('content')) {
                  final content = choice['delta']['content'];
                  yield content;
                }
              }
            }
          } catch (e) {
            // If JSON decoding fails, accumulate more data
            continue;
          }
        }
      }
      // Keep the last incomplete part if any
      accumulatedData = lines.last;
    }
  } else {
    throw Exception('Failed to load AI response');
  }
}

bool isImageAllow()  {
   final defaultAiModel = appSettingProvider.appSetting.value?.defaultAiModel;
   
  return defaultAiModel?.inputData?.contains('Image') ?? false;
}

bool isAudioAllow()  {
     final defaultAiModel = appSettingProvider.appSetting.value?.defaultAiModel;
  return defaultAiModel?.inputData?.contains('Audio') ?? false;
}

  void stopAIResponse() {
    _aiResponseSubscription?.cancel();
    finalizeAIResponse();
  }



  void toggleRecording() => isRecording.toggle();
  void togglePause() => isPaused.toggle();

  Future<void> loadConversations() async {
    try {
      isLoadingConversations(true);
      final newConversations =
          await provider.getConversations(page: currentPage);
      listConversations.addAll(newConversations);
      hasMoreConversations(newConversations.length == 10);
      updateDrawerList();
    } catch (e) {
      print('Error loading conversations: $e');
    } finally {
      isLoadingConversations(false);
    }
  }

  Future<void> loadMoreConversations() async {
    if (isLoadingMore.value || !hasMoreConversations.value) return;
    try {
      isLoadingMore(true);
      currentPage++;
      final newConversations =
          await provider.getConversations(page: currentPage);
      listConversations.addAll(newConversations);
      hasMoreConversations(newConversations.length == 10);
      updateDrawerList();
    } catch (e) {
      print('Error loading more conversations: $e');
    } finally {
      isLoadingMore(false);
    }
  }
void updateDrawerList() {
  drawerList.value = listConversations
      .where((conversation) =>
          conversation.id != null && 
          conversation.id!.isNotEmpty  
         )
      .map((conversation) => DrawerList(
            index: DrawerIndex.ChatAiChatView,
            labelName: conversation.title ?? 'New Chat',
            icon: const Icon(Icons.chat),
            imageName: '',
            id: conversation.id!, 
          ))
      .toList();
     
}



  Future<void> addNewConversation(String title) async {
    try {
      isLoading(true);
      setDefaultConversation();
      // final newConversation = await provider.addNewConversation(title);
      // listConversations.insert(0, );
      // setCurrentConversation(newConversation);
      updateDrawerList();
    } catch (e) {
      print('Error adding new conversation: $e');
    } finally {
      isLoading(false);
    }
  }

  Future<void> loadQuestionsAndAnswers() async {
    if (currentConversation.value?.id != null &&
        (currentConversation.value?.question?.isEmpty ?? true)) {
      isLoadingQuestions.value = true;
      try {
        final questions = await provider.getListQuestionAnswerByConversationId(
            currentConversation.value!.id!);
        updateConversation((val) {
          val.question = questions;
        });
      } catch (e) {
        Get.snackbar(
          'Error',
          'Failed to load questions and answers. Please try again later.',
          snackPosition: SnackPosition.BOTTOM,
          backgroundColor: Colors.redAccent,
          colorText: Colors.white,
          duration: Duration(seconds: 3),
        );
        print('Error loading questions and answers: $e');
      } finally {
        isLoadingQuestions.value = false;
      }
    }
  }

  Future<void> pickMultipleMedia() async {
    final ImagePicker picker = ImagePicker();
    final FilePickerResult? result = await FilePicker.platform.pickFiles(
      type: FileType.custom,
      allowedExtensions: ['jpg', 'jpeg', 'png', 'mp3', 'wav'],
      allowMultiple: true,
      
    );

    if (result != null) {
      selectedMediaFiles
          .addAll(result.paths.map((path) => File(path!)).toList());
      mediaUploadProgress.addAll(List.filled(result.files.length, 0.0));
      simulateMediaUpload();
    }
  }

  void simulateMediaUpload() async {
    for (int i = 0; i < selectedMediaFiles.length; i++) {
      for (int progress = 0; progress <= 100; progress++) {
        await Future.delayed(Duration(milliseconds: 50));
        mediaUploadProgress[i] = progress / 100;
      }
    }
  }

  void removeSelectedMedia(int index) {
    selectedMediaFiles.removeAt(index);
    mediaUploadProgress.removeAt(index);
  }
}
